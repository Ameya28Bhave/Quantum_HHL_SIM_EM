import numpy as np
import emulator as em
import simulator as sim
def runExperiment(A, b, applyRYs, t, numQubits, extraAncillas, shots=2048,emFig='emulator.png', simFig='simulator.png', dpi=300):
    '''
    A function that simulates the HHL algorithm using the process explained in
    section II of https://arxiv.org/pdf/2108.09004.pdf.
    Parameters:
    1 2 3 4 5 6 7 8 9
    10 11 12 13 14 15 16 17 18 19 20 21 22 23 24
    : The matrix A from the system Ax = b.
    : The vector b from the system Ax = b.
    : A function to apply the controlled y rotations.
    : A value needed for the QPE matrices.
    : The number of qubits used in the algorithm.
    A (np.ndarray)
    b (np.ndarray)
    applyRYs (func)
    t (float)
    numQubits (int)
    extraAncillas (int) : The number of extra ancillas (used in applyRYs).
    shots (int)
    emFig (string)
    simFig (string)
    dpi (int)
    : The number of shots to run.
    : The name to save the emulator histogram under.
    : The name to save the simulator histogram under.
    : The dpi of the histogram.
    Returns:
    An estimation of x as given by the HHL algorith.
    15
    25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85
        Also returns the time taken to perform the emulation.
        Finally saves a plot of the distribution generated by the algorithm.
    '''
    print('Begin Experiment')
    # Compute the solution, the simulator estimate, and the emulator estimate.
    x = np.linalg.solve(A, b)
    actual = (x / np.linalg.norm(x))**2
    simEstimate, simTime = sim.simulateHHL(
        A, b, applyRYs, t, numQubits, extraAncillas,
        shots=shots, figfile=simFig, dpi=dpi
    )
    emEstimate, emTime = em.emulateHHL(
        A, b, shots=shots, figfile=emFig, dpi=dpi
)
    # Print results.
    print('A=['
        + np.array_str(A[0], precision=2,) + ','
        + np.array_str(A[1], precision=2) + '], b='
        + np.array_str(b, precision=2)
    )
    print('Actual x\t:', actual)
    print('Simulated x\t:', simEstimate)
    print('Emulated x\t:', emEstimate)
    print('Sim Time\t:', simTime)
    print('Em Time \t:', emTime)
    print('Sim Avg Time\t:', simTime/shots)
    print('Em Avg Time\t:', emTime/shots)
    print('End Experiment')
    print()

def applyToffoli(psi, a, b, c): 
    '''
    Apply a Toffoli gate to a quantum register.
    Parameters:
    psi (QuantumRegister)
    a (int)
    b (int)
    c (int)
    : A quantum state.
    : The index of the first control qubit.
    : The index of the second control qubit.
    : The index of the target qubit.
    Returns:
        The QuantumRegister after the Toffoli gate has been applied.
    '''
    # Apply the Toffoli using the decomposition in Nielsen and Chuang.
    psi.ApplyHadamard(c)
    psi.ApplyCPauliX(b, c)
    psi.ApplyRotationZ(c, -np.pi/4.)
    psi.ApplyCPauliX(a, c)
    psi.ApplyRotationZ(c, np.pi/4.)
    psi.ApplyCPauliX(b, c)
    psi.ApplyRotationZ(c, -np.pi/4.)
    psi.ApplyCPauliX(a, c)
    psi.ApplyRotationZ(b, -np.pi/4.)
    psi.ApplyRotationZ(c, np.pi/4.)
    psi.ApplyCPauliX(a, b)
    psi.ApplyHadamard(c)
    psi.ApplyRotationZ(b, -np.pi/4.)
    psi.ApplyCPauliX(a, b)
    psi.ApplyRotationZ(a, np.pi/4.)
    psi.ApplyRotationZ(b, np.pi/2.) # Return psi.
    return psi

    def RY1(psi): 
        '''
        The controlled y-rotation gates for experiment 1.
        Parameters:
            psi (QuantumRegister)   : A quantum state.
        Returns:
            The QuantumRegister after the y-rotations have been applied.
        '''
        # Apply the needed y rotations and return.
        psi.ApplyCRotationY(1, 0, np.pi)
        psi.ApplyCRotationY(2, 0, np.pi/3.)
        return psi
    
def RY2(psi): 
    '''
    The controlled y-rotation gates for experiment 2.
    Parameters:
        psi (QuantumRegister)   : A quantum state.
    Returns:
        The QuantumRegister after the y-rotations have been applied.
    '''
    # Apply the needed y rotations and return.
    psi = applyToffoli(psi, 2, 3, 5)
    psi.ApplyCRotationY(5, 0, np.pi)
    psi = applyToffoli(psi, 2, 3, 5)
    psi = applyToffoli(psi, 1, 2, 5)
    psi = applyToffoli(psi, 3, 5, 6)
    psi.ApplyCRotationY(6, 0, np.pi/3.)
    psi = applyToffoli(psi, 3, 5, 6)
    psi = applyToffoli(psi, 1, 2, 5)
    return psi

runExperiment(np.array([[1 , -1/3], [-1/3 , 1]]), np.array([0, 1]), RY1, 3 * np.pi / 4, 4, 0, emFig='em1.png', simFig='sim1.png')
runExperiment(np.array([[13/2., -1/2.], [-1/2., 13/2]]), np.array([0, 1]), RY2, np.pi/4, 5, 2, emFig='em2.png', simFig='sim2.png')